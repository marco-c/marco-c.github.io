---
title: How to collect code coverage on Windows with Clang
tags: [code-coverage]
---

With Clang 6, support for collecting code coverage information on Windows should be mature enough to be used in production (indeed, we are using it to collect info for Firefox!).

In this post, I will show you a simple example to go from a C++ source file to a coverage report (in a readable format or in a JSON format that you can parse yourself to generate your custom nice reports or that you can upload to Coveralls/Codecov).

### Build
Let's say we have a simple file, main.cpp:
{% highlight c++ %}
#include <iostream>

int main() {
  int reply = 42;

  if (reply == 42) {
    std::cout << "42\n";
  } else {
    std::cout << "impossible\n";
  }

  return 0;
}
{% endhighlight %}

In order to make Clang generate an instrumented binary, we need to pass the '-\-coverage' option to clang:
<pre style="background-color:black;color:white;">
clang-cl --coverage main.cpp
</pre>

In the directory where main.cpp is, you will now see both the executable file of your program and a file with extension 'gcno'. This file contains information about the structure of the source file (functions, branches, basic blocks, and so on).

<pre style="background-color:black;color:white;">
09/01/2018  16:21    &lt;DIR&gt;          .
09/01/2018  16:21    &lt;DIR&gt;          ..
09/01/2018  16:20               173 main.cpp
09/01/2018  16:21           309.248 main.exe
09/01/2018  16:21            88.372 main.gcno
</pre>

### Run
Now, you can run your instrumented executable. It will generate another file with extension 'gcda', containing the coverage counters associated with the 'gcno' file (how many times a line was executed, how many times a branch was taken, and so on).

<pre style="background-color:black;color:white;">
09/01/2018  16:22    &lt;DIR&gt;          .
09/01/2018  16:22    &lt;DIR&gt;          ..
09/01/2018  16:20               173 main.cpp
09/01/2018  16:21           309.248 main.exe
09/01/2018  16:22            21.788 main.gcda
09/01/2018  16:21            88.372 main.gcno
</pre>

At this point, we need a tool to parse the gcno/gcda file that was generated by Clang. There are two options, llvm-cov and grcov. llvm-cov is part of LLVM and can generate bare bones reports, grcov is a separate tool and can generate LCOV, Coveralls and Codecov reports.

### Parse with llvm-cov
You can simply run:
<pre style="background-color:black;color:white;">
llvm-cov gcov main.gcno
</pre>

Several files with extension gcov will be generated (one for each source file of your project, including system header files).
For example, here's main.cpp.gcov:
<pre>
        -:    0:Source:main.cpp
        -:    0:Graph:main.gcno
        -:    0:Data:main.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include &lt;iostream&gt;
        -:    2:
        -:    3:int main() {
        1:    4:  int reply = 42;
        -:    5:
        1:    6:  if (reply == 42) {
        1:    7:    std::cout << "42\n";
        1:    8:  } else {
    #####:    9:    std::cout << "impossible\n";
        -:   10:  }
        -:   11:
        1:   12:  return 0;
        -:   13:}
</pre>

### Parse with grcov
[grcov](https://github.com/marco-c/grcov), can be downloaded from GitHub ([in the Releases page](https://github.com/marco-c/grcov/releases)).

Simply execute grcov with the '-\-llvm' option, pointing it to the directory containing your gcda/gcno files. The "-t" option allows you to specify the output format:
- "lcov" for the LCOV format, which you can then translate to a HTML report using genhtml;
- "coveralls" for a JSON format compatible with Coveralls/Codecov;
- "coveralls+" for an extension of the former, with addition of function information.

Example:
<pre style="background-color:black;color:white;">
grcov --llvm PATH_TO_YOUR_DIRECTORY -t coveralls+ --token unused --commit-sha unused > report.json
</pre>

grcov has other options too, simply run it with no parameters to list them. The most important one probably being "-\-branch", which adds the branch information to the output.

### In production
We are using Clang to collect code coverage on Windows for Firefox. The [grcov](https://github.com/marco-c/grcov) tool is used to parse the gcno/gcda files generated by LLVM and to emit a report that can be converted to HTML or uploaded to services such as Coveralls or Codecov.

We have fixed several bugs that were preventing GCOV coverage to be usable in Clang 5 (and previous versions), but with Clang 6 the situation should be pretty good (if it works with the millions of lines of code of Firefox, with its highly parallel architecture and with several diverse kinds of test suites, you can rest assured that it will work for most projects!).
